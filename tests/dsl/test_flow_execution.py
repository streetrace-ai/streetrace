"""Tests for DSL flow execution.

Test that generated flows properly execute with ADK integration
and yield events from agent runs.
"""

from collections.abc import AsyncGenerator
from typing import TYPE_CHECKING
from unittest.mock import MagicMock

import pytest

if TYPE_CHECKING:
    from google.adk.events import Event

    from streetrace.dsl.runtime.context import WorkflowContext
    from streetrace.dsl.runtime.workflow import DslAgentWorkflow


def create_mock_event(text: str) -> MagicMock:
    """Create a mock ADK event with the given text result."""
    event = MagicMock()
    event.is_final_response.return_value = True
    event.content = MagicMock()
    event.content.parts = [MagicMock(text=text)]
    return event


@pytest.fixture
def mock_workflow() -> "DslAgentWorkflow":
    """Create a mock DslAgentWorkflow for testing."""
    return MagicMock()


class TestFlowExecution:
    """Test flow execution basics - context delegation to workflow."""

    @pytest.fixture
    def workflow_context(self, mock_workflow: "DslAgentWorkflow") -> "WorkflowContext":
        """Create a WorkflowContext with test configuration."""
        from streetrace.dsl.runtime.context import WorkflowContext

        ctx = WorkflowContext(workflow=mock_workflow)

        # Set up models
        ctx.set_models({
            "main": "anthropic/claude-sonnet",
            "summarizer": "anthropic/claude-haiku",
        })

        # Set up prompts with lambdas (as generated by codegen)
        ctx.set_prompts({
            "analyze_prompt": lambda c: f"Analyze: {c.vars.get('input_prompt', '')}",
            "summarize_prompt": lambda _: "Summarize the input.",
        })

        # Set up prompt models (which model each prompt uses)
        ctx._prompt_models = {  # noqa: SLF001
            "analyze_prompt": "main",
            "summarize_prompt": "summarizer",
        }

        # Set up agents
        ctx.set_agents({
            "analyzer": {
                "instruction": "analyze_prompt",
                "tools": ["fs"],
            },
            "summarizer": {
                "instruction": "summarize_prompt",
                "tools": [],
            },
        })

        return ctx

    @pytest.mark.asyncio
    async def test_simple_flow_runs_agent(
        self,
        workflow_context: "WorkflowContext",
        mock_workflow: "DslAgentWorkflow",
    ) -> None:
        """A simple flow that runs a single agent delegates to workflow."""
        captured_calls: list[tuple[str, tuple[object, ...]]] = []

        async def mock_run_agent(
            agent_name: str,
            *args: object,
        ) -> AsyncGenerator["Event", None]:
            captured_calls.append((agent_name, args))
            # Set result in context for retrieval
            workflow_context._last_call_result = "Analysis result"  # noqa: SLF001
            yield create_mock_event("Analysis result")

        mock_workflow.run_agent = mock_run_agent

        # Run agent and check events
        workflow_context.vars["input_prompt"] = "test input"
        events = [
            event
            async for event in workflow_context.run_agent("analyzer", "test input")
        ]

        assert len(captured_calls) == 1
        assert captured_calls[0] == ("analyzer", ("test input",))
        assert len(events) == 1

    @pytest.mark.asyncio
    async def test_flow_variable_passing(
        self,
        workflow_context: "WorkflowContext",
        mock_workflow: "DslAgentWorkflow",
    ) -> None:
        """Flow variables can be passed between delegated agent runs."""
        call_count = 0

        async def mock_run_agent(
            agent_name: str,  # noqa: ARG001
            *args: object,  # noqa: ARG001
        ) -> AsyncGenerator["Event", None]:
            nonlocal call_count
            result = "step1 result" if call_count == 0 else "step2 result"
            workflow_context._last_call_result = result  # noqa: SLF001
            call_count += 1
            yield create_mock_event(result)

        mock_workflow.run_agent = mock_run_agent

        # Simulate flow: $analysis = run agent analyzer
        # $summary = run agent summarizer $analysis
        workflow_context.vars["input_prompt"] = "test input"

        # Step 1: Run analyzer
        _ = [event async for event in workflow_context.run_agent("analyzer")]
        workflow_context.vars["analysis"] = workflow_context.get_last_result()

        # Step 2: Run summarizer with analysis result
        _ = [
            event
            async for event in workflow_context.run_agent(
                "summarizer",
                workflow_context.vars["analysis"],
            )
        ]
        workflow_context.vars["summary"] = workflow_context.get_last_result()

        assert workflow_context.vars["analysis"] == "step1 result"
        assert workflow_context.vars["summary"] == "step2 result"


class TestSequentialFlowExecution:
    """Test sequential flow execution patterns."""

    @pytest.fixture
    def workflow_context(self, mock_workflow: "DslAgentWorkflow") -> "WorkflowContext":
        """Create a WorkflowContext for sequential flow tests."""
        from streetrace.dsl.runtime.context import WorkflowContext

        ctx = WorkflowContext(workflow=mock_workflow)
        ctx.set_models({"main": "test-model"})
        ctx.set_prompts({
            "step1_prompt": lambda _: "Step 1 instruction",
            "step2_prompt": lambda _: "Step 2 instruction",
        })
        ctx.set_agents({
            "step1_agent": {"instruction": "step1_prompt", "tools": []},
            "step2_agent": {"instruction": "step2_prompt", "tools": []},
        })
        return ctx

    @pytest.mark.asyncio
    async def test_sequential_flow_runs_agents_in_order(
        self,
        workflow_context: "WorkflowContext",
        mock_workflow: "DslAgentWorkflow",
    ) -> None:
        """Sequential agents should call workflow.run_agent in order."""
        execution_order: list[str] = []

        async def mock_run_agent(
            agent_name: str,
            *args: object,  # noqa: ARG001
        ) -> AsyncGenerator["Event", None]:
            execution_order.append(agent_name)
            workflow_context._last_call_result = f"{agent_name} result"  # noqa: SLF001
            yield create_mock_event(f"{agent_name} result")

        mock_workflow.run_agent = mock_run_agent

        # Run sequential flow
        _ = [event async for event in workflow_context.run_agent("step1_agent")]
        result1 = workflow_context.get_last_result()

        _ = [event async for event in workflow_context.run_agent("step2_agent")]
        result2 = workflow_context.get_last_result()

        assert result1 == "step1_agent result"
        assert result2 == "step2_agent result"
        assert execution_order == ["step1_agent", "step2_agent"]


class TestFlowWithDataTransformation:
    """Test flow execution with data transformations."""

    @pytest.fixture
    def workflow_context(self, mock_workflow: "DslAgentWorkflow") -> "WorkflowContext":
        """Create a WorkflowContext for data transformation tests."""
        from streetrace.dsl.runtime.context import WorkflowContext

        ctx = WorkflowContext(workflow=mock_workflow)
        ctx.set_models({"main": "test-model"})
        ctx.set_prompts({
            "analysis_prompt": lambda _: "Analyze the input",
            "format_prompt": lambda _: "Format the analysis",
        })
        ctx.set_agents({
            "analyzer": {"instruction": "analysis_prompt", "tools": []},
            "formatter": {"instruction": "format_prompt", "tools": []},
        })
        return ctx

    @pytest.mark.asyncio
    async def test_flow_with_data_transformation(
        self,
        workflow_context: "WorkflowContext",
        mock_workflow: "DslAgentWorkflow",
    ) -> None:
        """Flow should delegate data transformation to workflow."""
        results = ['{"key": "value"}', "Formatted: key=value"]
        call_count = 0

        async def mock_run_agent(
            agent_name: str,  # noqa: ARG001
            *args: object,  # noqa: ARG001
        ) -> AsyncGenerator["Event", None]:
            nonlocal call_count
            result = results[call_count]
            workflow_context._last_call_result = result  # noqa: SLF001
            call_count += 1
            yield create_mock_event(result)

        mock_workflow.run_agent = mock_run_agent

        # Step 1: Get raw analysis
        _ = [
            event
            async for event in workflow_context.run_agent("analyzer", "input data")
        ]
        workflow_context.vars["analysis"] = workflow_context.get_last_result()

        # Step 2: Format the analysis
        _ = [
            event
            async for event in workflow_context.run_agent(
                "formatter",
                workflow_context.vars["analysis"],
            )
        ]
        workflow_context.vars["result"] = workflow_context.get_last_result()

        assert workflow_context.vars["analysis"] == '{"key": "value"}'
        assert workflow_context.vars["result"] == "Formatted: key=value"


class TestExpressionVisitorTokenHandling:
    """Test that ExpressionVisitor properly handles Token edge cases."""

    def test_token_in_expression_raises_error(self) -> None:
        """ExpressionVisitor should raise an error for unhandled Tokens."""
        from lark import Token

        from streetrace.dsl.codegen.visitors.expressions import ExpressionVisitor

        visitor = ExpressionVisitor()
        token = Token("RETURN", "return")

        with pytest.raises(ValueError) as exc_info:
            visitor.visit(token)

        assert "Unhandled Token in expression" in str(exc_info.value)
        assert "RETURN" in str(exc_info.value)

    def test_all_known_expression_types_handled(self) -> None:
        """All known expression node types should be handled."""
        from streetrace.dsl.ast.nodes import (
            BinaryOp,
            FunctionCall,
            ListLiteral,
            Literal,
            NameRef,
            ObjectLiteral,
            PropertyAccess,
            UnaryOp,
            VarRef,
        )
        from streetrace.dsl.codegen.visitors.expressions import ExpressionVisitor

        visitor = ExpressionVisitor()

        # Test each expression type
        var_ref = VarRef(name="test")
        assert visitor.visit(var_ref) == "ctx.vars['test']"

        literal = Literal(value=42, literal_type="int")
        assert visitor.visit(literal) == "42"

        string_literal = Literal(value="hello", literal_type="string")
        assert visitor.visit(string_literal) == '"hello"'

        bool_literal = Literal(value=True, literal_type="bool")
        assert visitor.visit(bool_literal) == "True"

        null_literal = Literal(value=None, literal_type="null")
        assert visitor.visit(null_literal) == "None"

        binary_op = BinaryOp(
            op=">",
            left=VarRef(name="x"),
            right=Literal(value=10, literal_type="int"),
        )
        assert visitor.visit(binary_op) == "(ctx.vars['x'] > 10)"

        unary_op = UnaryOp(op="not", operand=VarRef(name="x"))
        assert visitor.visit(unary_op) == "(not ctx.vars['x'])"

        name_ref = NameRef(name="some_name")
        assert visitor.visit(name_ref) == "ctx.vars['some_name']"

        list_lit = ListLiteral(elements=[Literal(value=1, literal_type="int")])
        assert visitor.visit(list_lit) == "[1]"

        obj_lit = ObjectLiteral(
            entries={"key": Literal(value="val", literal_type="string")},
        )
        assert '"key": "val"' in visitor.visit(obj_lit)

        prop_access = PropertyAccess(base=VarRef(name="obj"), properties=["field"])
        assert visitor.visit(prop_access) == "ctx.vars['obj']['field']"

        func_call = FunctionCall(name="initial_user_prompt", args=[])
        assert visitor.visit(func_call) == "ctx.vars['input_prompt']"


class TestCodeGenerationForFlows:
    """Test code generation produces correct flow code."""

    def test_generated_flow_code_compiles(self) -> None:
        """Generated flow code should be valid Python by compiling flow.sr."""
        from pathlib import Path

        from streetrace.dsl.ast.transformer import transform
        from streetrace.dsl.codegen.generator import CodeGenerator
        from streetrace.dsl.grammar.parser import ParserFactory
        from streetrace.dsl.runtime.workflow import DslAgentWorkflow

        # Use the actual flow.sr example file
        flow_file = Path("agents/examples/dsl/flow.sr")
        if not flow_file.exists():
            pytest.skip("flow.sr example file not found")

        source = flow_file.read_text()

        # Parse, transform, and generate code
        # Note: we bypass semantic analysis which has a separate bug
        parser = ParserFactory.create()
        tree = parser.parse(source)
        ast = transform(tree)

        generator = CodeGenerator()
        python_code, _ = generator.generate(ast, str(flow_file))

        # Compile the generated Python code to verify it's valid
        bytecode = compile(python_code, str(flow_file), "exec")
        assert bytecode is not None

        # Execute to create the workflow class (safe DSL-generated code)
        namespace: dict[str, object] = {}
        exec(bytecode, namespace)  # noqa: S102

        # Check that the workflow class was created
        workflow_class = None
        for obj in namespace.values():
            is_workflow_subclass = (
                isinstance(obj, type)
                and issubclass(obj, DslAgentWorkflow)
                and obj.__name__ != "DslAgentWorkflow"
            )
            if is_workflow_subclass:
                workflow_class = obj
                break

        assert workflow_class is not None

    def test_flow_return_generates_proper_code(self) -> None:
        """Return statement should store value in context and use bare return.

        In async generators, 'return value' is not allowed. The generated code
        stores the return value in ctx.vars['_return_value'] and uses a bare return.
        """
        from streetrace.dsl.ast.nodes import FlowDef, Literal, ReturnStmt
        from streetrace.dsl.codegen.emitter import CodeEmitter
        from streetrace.dsl.codegen.visitors.flows import FlowVisitor

        emitter = CodeEmitter("test.sr")
        visitor = FlowVisitor(emitter)

        flow = FlowDef(
            name="test_flow",
            params=[],
            body=[
                ReturnStmt(value=Literal(value="success", literal_type="string")),
            ],
        )

        visitor.visit(flow)
        code = emitter.get_code()

        assert "async def flow_test_flow" in code
        # Return stores value in context since flow is async generator
        assert 'ctx.vars[\'_return_value\'] = "success"' in code
        assert "return" in code
