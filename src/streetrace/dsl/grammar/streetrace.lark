// ============================================================================
// STREETRACE DSL GRAMMAR v1.0
// Lark EBNF Grammar for the Streetrace Agent Definition Language
// ============================================================================

// ----------------------------------------------------------------------------
// START RULE
// ----------------------------------------------------------------------------

start: _NL* version_decl? (_NL* statement)* _NL*

version_decl: "streetrace" VERSION _NL

// VERSION has higher priority (.3) than NAME to match v1, v1.2, etc.
VERSION.3: /v[0-9]+(\.[0-9]+)?/

// ----------------------------------------------------------------------------
// STATEMENTS (Top-Level Constructs)
// ----------------------------------------------------------------------------

statement: import_stmt
         | model_def
         | schema_def
         | tool_def
         | retry_policy_def
         | timeout_policy_def
         | policy_def
         | event_handler
         | flow_def
         | agent_def
         | prompt_def

// ----------------------------------------------------------------------------
// IMPORTS
// ----------------------------------------------------------------------------

import_stmt: "import" import_source
           | "import" NAME "from" import_source

import_source: "streetrace"                           -> import_streetrace
             | LOCAL_PATH                             -> import_local
             | PIP_URI                                -> import_pip
             | MCP_URI                                -> import_mcp

LOCAL_PATH: /\.\/[a-zA-Z0-9_\-\.\/]+\.sr/
PIP_URI: /pip:\/\/[a-zA-Z_][a-zA-Z0-9_]*/
MCP_URI: /mcp:\/\/[a-zA-Z_][a-zA-Z0-9_]*/

// ----------------------------------------------------------------------------
// MODELS
// ----------------------------------------------------------------------------

model_def: "model" NAME "=" model_ref                 -> model_short
         | "model" NAME ":" _NL _INDENT model_body _DEDENT -> model_long

model_ref: PROVIDER_MODEL
         | NAME

// Provider/model format: anthropic/claude-sonnet, openai/gpt-4
// Priority .3 ensures it matches before DOTTED_NAME
PROVIDER_MODEL.3: /[a-zA-Z][a-zA-Z0-9_-]*\/[a-zA-Z][a-zA-Z0-9_.-]*/

model_body: model_property+

model_property: "provider" ":" NAME _NL               -> model_provider
              | "name" ":" NAME _NL                   -> model_name
              | "temperature" ":" NUMBER _NL          -> model_temperature
              | "max_tokens" ":" INT _NL              -> model_max_tokens

// ----------------------------------------------------------------------------
// SCHEMAS (Structured Outputs)
// ----------------------------------------------------------------------------

schema_def: "schema" NAME ":" _NL _INDENT schema_body _DEDENT

schema_body: schema_field+

// Schema field names can be keywords, so we use contextual_name
schema_field: field_name ":" type_expr _NL

// Field names can be regular names or soft keywords
field_name: NAME | contextual_keyword

type_expr: simple_type
         | list_type
         | optional_type

simple_type: "string" | "int" | "float" | "bool" | NAME

list_type: "list" LSQB type_expr RSQB

optional_type: type_expr "?"

// ----------------------------------------------------------------------------
// TOOLS
// ----------------------------------------------------------------------------

tool_def: "tool" NAME "=" tool_short_expr             -> tool_short
        | "tool" NAME ":" _NL _INDENT tool_body _DEDENT -> tool_long

tool_short_expr: "mcp" STRING tool_options?           -> tool_mcp
               | "builtin" DOTTED_NAME                -> tool_builtin
               | DOTTED_NAME                          -> tool_ref

tool_options: "with" tool_option ("," tool_option)*

tool_option: "auth" "bearer" interpolated_string      -> tool_auth_bearer
           | "auth" "basic" interpolated_string       -> tool_auth_basic
           | NAME interpolated_string                 -> tool_custom_option

tool_body: tool_property+

tool_property: "type" ":" tool_type_name _NL          -> tool_type
             | "url" ":" STRING _NL                   -> tool_url
             | "headers" ":" _NL _INDENT header_list _DEDENT -> tool_headers

// Tool type names can be keywords like mcp, builtin, etc.
tool_type_name: NAME | "mcp" | "builtin"

header_list: header_entry+

header_entry: NAME ":" interpolated_string _NL

// ----------------------------------------------------------------------------
// RETRY AND TIMEOUT POLICIES
// ----------------------------------------------------------------------------

// Uses identifier to allow keywords like "fixed" as retry policy names
retry_policy_def: "retry" identifier "=" INT "times" ("," backoff_strategy)?

backoff_strategy: "exponential" "backoff"             -> backoff_exponential
                | "linear" "backoff"                  -> backoff_linear
                | "fixed" "backoff"                   -> backoff_fixed

timeout_policy_def: "timeout" NAME "=" INT time_unit

time_unit: "seconds" | "minutes" | "hours"

// ----------------------------------------------------------------------------
// POLICIES (Generalized)
// ----------------------------------------------------------------------------

// General policy pattern: policy <name>: (e.g., policy compaction:)
// Follows the consistent <type> <name> pattern used by model, tool, agent, etc.
// Uses identifier to allow keywords like "compaction" as policy names
policy_def: "policy" identifier ":" _NL _INDENT policy_body _DEDENT

policy_body: policy_property+

policy_property: "trigger" ":" policy_trigger _NL
               | "strategy" ":" identifier _NL
               | "preserve" ":" preserve_list _NL
               | "use" "model" ":" interpolated_string _NL
               | identifier ":" expression _NL              -> policy_custom

// Trigger variable names (like tokens, token_count) can be keywords
policy_trigger: identifier comparison_op NUMBER

preserve_list: LSQB preserve_item ("," preserve_item)* RSQB

preserve_item: variable
             | "last" INT "messages"
             | "tool" "results"
             | STRING

// ----------------------------------------------------------------------------
// EVENT HANDLERS
// ----------------------------------------------------------------------------

event_handler: event_timing event_type "do" _NL _INDENT handler_body _DEDENT "end"

event_timing: "on"                                    -> timing_on
            | "after"                                 -> timing_after

event_type: "start"                                   -> event_start
          | "input"                                   -> event_input
          | "output"                                  -> event_output
          | "tool-call"                               -> event_tool_call
          | "tool-result"                             -> event_tool_result

handler_body: handler_statement+

handler_statement: guardrail_action _NL
                 | assignment _NL
                 | flow_control _NL
                 | run_stmt _NL
                 | call_stmt _NL
                 | push_stmt _NL
                 | escalate_stmt _NL
                 | log_stmt _NL
                 | notify_stmt _NL
                 | if_stmt _NL
                 | if_block
                 | for_loop
                 | parallel_block
                 | loop_block

// Inline if statement (single line)
if_stmt: "if" condition ":" statement_body

// ----------------------------------------------------------------------------
// GUARDRAIL ACTIONS
// ----------------------------------------------------------------------------

guardrail_action: mask_action
                | block_action
                | warn_action
                | retry_action

// mask_action takes a guardrail name (pii, jailbreak, etc) which may be a keyword
mask_action: "mask" identifier

block_action: "block" "if" condition

// General identifier that can be either NAME or a contextual keyword
identifier: NAME | contextual_keyword

warn_action: "warn" "if" condition
           | "warn" STRING
           | "warn" "if" expression "contains" STRING

retry_action: "retry" "with" expression "if" condition
            | "retry" "step" expression

// ----------------------------------------------------------------------------
// FLOWS
// ----------------------------------------------------------------------------

flow_def: "flow" flow_name ":" _NL _INDENT flow_body _DEDENT

// Flow names use underscores for consistency (e.g., "get_agent_goal")
// Multi-word flows are supported but we recommend snake_case for clarity
// Use identifier to allow keywords as part of flow names
flow_name: identifier+

flow_body: flow_statement+

flow_statement: assignment _NL
              | run_stmt _NL
              | call_stmt _NL
              | return_stmt _NL
              | for_loop
              | parallel_block
              | match_block
              | if_block
              | if_stmt _NL
              | push_stmt _NL
              | escalate_stmt _NL
              | log_stmt _NL
              | notify_stmt _NL
              | expression_stmt _NL
              | failure_block
              | flow_control _NL
              | loop_block

// Expression as statement (for function calls like lib.convert)
expression_stmt: function_call
               | property_access LPAR [expression ("," expression)*] RPAR

// ----------------------------------------------------------------------------
// AGENTS
// ----------------------------------------------------------------------------

agent_def: "agent" NAME? ":" _NL _INDENT agent_body _DEDENT

agent_body: agent_property+

agent_property: "tools" name_list _NL                 -> agent_tools
              | "instruction" NAME _NL                -> agent_instruction
              | "prompt" NAME _NL                     -> agent_prompt
              | "produces" NAME _NL                   -> agent_produces
              | "retry" NAME _NL                      -> agent_retry
              | "timeout" timeout_value _NL           -> agent_timeout
              | "description" STRING _NL              -> agent_description
              | "delegate" name_list _NL              -> agent_delegate
              | "use" name_list _NL                   -> agent_use

timeout_value: NAME                                   -> timeout_ref
             | INT time_unit                          -> timeout_literal

name_list: tool_name ("," tool_name)*

tool_name: NAME
         | DOTTED_NAME

// ----------------------------------------------------------------------------
// PROMPTS
// ----------------------------------------------------------------------------

// Prompt definitions support override pattern for better file organization:
// - Declarations (without body): define metadata at top of file
// - Full definitions (with body): define prompt text at bottom of file
// Multiple definitions of the same prompt are merged during semantic analysis.
// Example:
//   prompt reviewer expecting Schema using model "main"  # declaration
//   # ... agents and flows ...
//   prompt reviewer: """Prompt text here"""              # body definition

prompt_def: "prompt" NAME prompt_modifiers?                                      -> prompt_decl
          | "prompt" NAME prompt_modifiers? ":" prompt_body escalation_clause?   -> prompt_full

prompt_modifiers: prompt_modifier+

prompt_modifier: "using" "model" interpolated_string  -> prompt_using_model
               | "expecting" expecting_type           -> prompt_expecting
               | "inherit" variable                   -> prompt_inherit

expecting_type: NAME                                  -> expecting_single
             | NAME LSQB RSQB                         -> expecting_array

// Prompt body uses triple-quoted string for multi-line text
// This approach works better with Lark's lexer-first architecture
prompt_body: TRIPLE_QUOTED_STRING

// Prompt escalation clause - defines when output triggers escalation
// Syntax: escalate if <condition>
// Conditions: ~ STRING (normalized), == STRING, != STRING, contains STRING
escalation_clause: _NL _INDENT "escalate" "if" escalation_condition _NL _DEDENT

escalation_condition: "~" STRING                     -> normalized_escalation
                    | "==" STRING                    -> exact_escalation
                    | "!=" STRING                    -> not_equal_escalation
                    | "contains" STRING              -> contains_escalation

// Triple-quoted string captures multi-line prompt content
// Supports both triple-single and triple-double quotes
// Pattern allows single/double quotes inside - only triple-quote sequence ends the string
// Uses non-greedy match: """ followed by any chars (non-greedy) followed by """
TRIPLE_QUOTED_STRING: /\"{3}[\s\S]*?\"{3}/ | /'{3}[\s\S]*?'{3}/

// ----------------------------------------------------------------------------
// CONTROL FLOW
// ----------------------------------------------------------------------------

// Block statements end with "end" but may have trailing newline when followed by more statements
for_loop: "for" variable "in" expression "do" _NL _INDENT flow_body _DEDENT "end" _NL?

parallel_block: "parallel" "do" _NL _INDENT flow_body _DEDENT "end" _NL?

// Loop block for iterative refinement pattern
loop_block: "loop" "max" INT "do" _NL _INDENT flow_body _DEDENT "end" _NL?
          | "loop" "do" _NL _INDENT flow_body _DEDENT "end" _NL?

match_block: "match" expression _NL _INDENT match_cases _DEDENT "end" _NL?

match_cases: match_case+ match_else?

match_case: "when" STRING "->" flow_statement

match_else: "else" "->" flow_statement

// If block can optionally consume trailing newline when followed by more statements
if_block: "if" condition ":" _NL _INDENT flow_body _DEDENT _NL?

flow_control: "continue"
            | "abort"
            | "retry" "step" expression

// ----------------------------------------------------------------------------
// STATEMENTS
// ----------------------------------------------------------------------------

assignment: variable "=" expression

// Agent names and flow names can be keywords (identifier allows this)
// Flows are called with "run flow_name [args]" syntax
// Optional escalation_handler: ", on escalate <action>"
run_stmt: variable "=" "run" "agent" identifier ("with" expression)? escalation_handler?
        | "run" "agent" identifier ("with" expression)? escalation_handler?
        | variable "=" "run" identifier ("with" expression)? escalation_handler?  -> run_flow_assign
        | "run" identifier ("with" expression)? escalation_handler?  -> run_flow

// Escalation handler for run statements
// Syntax: , on escalate <action>
escalation_handler: "," "on" "escalate" escalation_action

escalation_action: "return" expression               -> escalation_return
                 | "continue"                        -> escalation_continue
                 | "abort"                           -> escalation_abort

call_stmt: variable "=" "call" "llm" identifier ("with" expression)? call_modifiers?
         | "call" "llm" identifier ("with" expression)? call_modifiers?

call_modifiers: "using" "model" interpolated_string

return_stmt: "return" expression

push_stmt: "push" expression "to" variable

escalate_stmt: "escalate" "to" "human" STRING?

log_stmt: "log" expression

notify_stmt: "notify" expression

// ----------------------------------------------------------------------------
// FAILURE HANDLING
// ----------------------------------------------------------------------------

// on failure block attaches to preceding statement
failure_block: "on" "failure" ":" _NL _INDENT failure_body _DEDENT

failure_body: flow_statement+

// Statement body for inline if (single line after colon)
statement_body: run_stmt
              | call_stmt
              | push_stmt
              | escalate_stmt
              | log_stmt
              | notify_stmt
              | flow_control
              | guardrail_action

// ----------------------------------------------------------------------------
// EXPRESSIONS
// ----------------------------------------------------------------------------

?expression: or_expr

?or_expr: and_expr ("or" and_expr)*

?and_expr: not_expr ("and" not_expr)*

?not_expr: "not" not_expr                             -> not_op
         | comparison

?comparison: filter_expr
           | additive (comparison_op additive)?

comparison_op: ">" | "<" | ">=" | "<=" | "==" | "!=" | "contains" | "~"

?additive: multiplicative (("+"|"-") multiplicative)*

?multiplicative: unary (("*"|"/"|"%") unary)*

?unary: "-" unary                                     -> neg
      | atom

?atom: literal
     | variable
     | property_access
     | function_call
     | identifier                                     -> name_ref
     | LPAR expression RPAR                           -> paren_expr
     | implicit_property

// Implicit property access for filter conditions (e.g., .confidence, .nested.prop)
// DOTTED_NAME handles nested properties like .finding.severity being lexed as one token
implicit_property: "." contextual_name ("." contextual_name)*
                 | "." DOTTED_NAME

// Filter expression for list filtering (e.g., filter $items where .score > 50)
// At unary level. The condition uses or_expr to capture full boolean expressions
// while avoiding ambiguity with the outer expression structure
filter_expr: "filter" atom "where" or_expr

literal: STRING                                       -> string_lit
       | NUMBER                                       -> number_lit
       | INT                                          -> int_lit
       | "true"                                       -> true_lit
       | "false"                                      -> false_lit
       | "null"                                       -> null_lit
       | list_literal
       | object_literal
       | "initial" "user" "prompt"                    -> initial_prompt

list_literal: LSQB [expression ("," expression)*] RSQB

// Object literals: { key: value, key2: value2 }
// Used in return statements, assignments, and expressions
object_literal: LBRACE [object_entry ("," object_entry)*] RBRACE

// Object keys can be keywords like success, result, etc.
object_entry: identifier ":" expression

// Variable names can be keywords, so we accept NAME or contextual_keyword
// Note: $var.prop.path is lexed as $ + DOTTED_NAME due to terminal priority
// $ prefix is optional in flow context â€” both $var and var are accepted
variable: "$" var_name                                -> var_ref
        | "$" DOTTED_NAME                             -> var_dotted
        | var_name                                    -> var_bare

// Variable names can be regular identifiers or soft keywords
var_name: NAME | contextual_keyword

// Contextual keywords - words that are keywords in specific positions
// but can be used as identifiers (field names, property names) in others.
// This follows the Python 3.10 soft keyword pattern.
contextual_keyword: "escalate" | "match" | "from" | "to" | "agent" | "model"
                  | "block" | "mask" | "warn" | "retry" | "push" | "run"
                  | "call" | "return" | "trigger" | "strategy" | "preserve"
                  | "passed" | "score" | "message" | "category" | "urgency"
                  | "type" | "url" | "headers" | "auth" | "use" | "human"
                  | "input" | "output" | "start" | "end" | "do" | "if"
                  | "for" | "in" | "parallel" | "when" | "else" | "flow"
                  | "prompt" | "schema" | "tool" | "import" | "on" | "after"
                  | "policy" | "compaction" | "success" | "reason" | "failure"
                  | "debit" | "credit" | "result" | "results" | "data"
                  | "jailbreak" | "pii" | "not" | "item" | "items"
                  | "last" | "messages" | "goal" | "drift" | "trajectory"
                  | "detect" | "get" | "builtin" | "mcp" | "process"
                  | "timeout" | "initial" | "user" | "llm" | "step"
                  | "fixed" | "exponential" | "linear" | "basic" | "bearer"
                  | "backoff" | "times" | "instruction" | "tools" | "description"
                  | "expecting" | "using" | "inherit" | "delegate" | "loop" | "max"
                  | "filter" | "where" | "with" | "produces"

// Contextual names - includes NAME and contextual keywords
// Used for property access where keywords can appear after dot
contextual_name: NAME | contextual_keyword

// Property access for both NAME.prop and $var.prop patterns
// Deep property access for nested objects (e.g., $tool_result.guardrails.passed)
property_access: NAME "." contextual_name ("." contextual_name)*
               | variable "." contextual_name ("." contextual_name)*
               | DOTTED_NAME

// Function calls for library functions and utility methods
// User-defined flows are called using "run flow_name" syntax (see run_stmt)
function_call: DOTTED_NAME LPAR [expression ("," expression)*] RPAR
             | NAME LPAR [expression ("," expression)*] RPAR  -> named_function_call
             | NAME expression+                       -> bare_function_call
             | "process" expression                   -> process_call

// Condition is a boolean expression
// Simplified: expression already handles variable, property access, and negation
// The contextual_name rule ensures property names can match keywords
?condition: expression

// ----------------------------------------------------------------------------
// INTERPOLATED STRINGS
// ----------------------------------------------------------------------------

interpolated_string: STRING
                   | INTERPOLATED_STRING

// Interpolation patterns: ${env:VAR}, $variable, ${variable}
INTERPOLATED_STRING: /"[^"]*(\$\{[^}]+\}|\$[a-zA-Z_][a-zA-Z0-9_]*)[^"]*"/

// ----------------------------------------------------------------------------
// TERMINALS
// ----------------------------------------------------------------------------

// Identifiers
NAME: /[a-zA-Z_][a-zA-Z0-9_-]*/
// DOTTED_NAME has priority .2 to match before NAME sequences
DOTTED_NAME.2: /[a-zA-Z_][a-zA-Z0-9_-]*(\.[a-zA-Z_][a-zA-Z0-9_-]*)+/

// Literals
STRING: /"[^"]*"/ | /'[^']*'/
INT: /[0-9]+/
// NUMBER with decimal has priority .2 to match before INT
NUMBER.2: /[0-9]+\.[0-9]+/

// Comments (ignored)
SH_COMMENT: /#[^\n]*/

// Brackets and parentheses (for Indenter recognition)
LPAR: "("
RPAR: ")"
LSQB: "["
RSQB: "]"
LBRACE: "{"
RBRACE: "}"

// Whitespace handling
_NL: (/\r?\n[\t ]*/ | SH_COMMENT)+
WS_INLINE: /[\t ]+/

%ignore WS_INLINE
%ignore SH_COMMENT

// Indentation tokens (declared, generated by Indenter postlex)
%declare _INDENT _DEDENT

// ----------------------------------------------------------------------------
// IMPORTS FROM COMMON
// ----------------------------------------------------------------------------

%import common.ESCAPED_STRING
%import common.SIGNED_NUMBER
%import common.WS
