"""Workflow visitor for DSL code generation.

Generate the main Python workflow class structure.
"""

from streetrace.dsl.ast.nodes import (
    AgentDef,
    DslFile,
    EventHandler,
    FlowDef,
    ModelDef,
    PromptDef,
    SchemaDef,
    ToolDef,
)
from streetrace.dsl.codegen.emitter import CodeEmitter
from streetrace.dsl.codegen.visitors.flows import FlowVisitor
from streetrace.dsl.codegen.visitors.handlers import HandlerVisitor
from streetrace.log import get_logger

logger = get_logger(__name__)

# Header comment for generated code
GENERATED_HEADER = '''"""Generated workflow from {source_file}.

Auto-generated by Streetrace DSL Compiler.
Do not edit directly - modify the .sr source file instead.
"""

'''

# Required imports for generated code
IMPORTS = """from typing import Any

import asyncio

from streetrace.dsl.runtime.context import WorkflowContext
from streetrace.dsl.runtime.workflow import DslAgentWorkflow
from streetrace.dsl.runtime.errors import (
    AbortError,
    BlockedInputError,
    RetryInputError,
    RetryStepError,
)

"""


class WorkflowVisitor:
    """Generate the main Python workflow class structure.

    Visit the DSL file AST and emit a complete Python module
    containing the workflow class with all definitions.
    """

    def __init__(self, emitter: CodeEmitter) -> None:
        """Initialize the workflow visitor.

        Args:
            emitter: Code emitter for output generation.

        """
        self._emitter = emitter
        self._models: list[ModelDef] = []
        self._prompts: list[PromptDef] = []
        self._tools: list[ToolDef] = []
        self._schemas: list[SchemaDef] = []
        self._agents: list[AgentDef] = []
        self._flows: list[FlowDef] = []
        self._handlers: list[EventHandler] = []

    def visit(self, node: DslFile, source_file: str) -> None:
        """Visit a DSL file and generate the complete workflow class.

        Args:
            node: DSL file AST node.
            source_file: Name of the source file.

        """
        # Collect all definitions
        self._collect_definitions(node)

        # Emit header and imports
        self._emit_header(source_file)
        self._emit_imports()

        # Emit the workflow class
        self._emit_class_definition(source_file)

    def _collect_definitions(self, node: DslFile) -> None:
        """Collect all definitions from the AST.

        Args:
            node: DSL file AST node.

        """
        for stmt in node.statements:
            if isinstance(stmt, ModelDef):
                self._models.append(stmt)
            elif isinstance(stmt, PromptDef):
                self._prompts.append(stmt)
            elif isinstance(stmt, ToolDef):
                self._tools.append(stmt)
            elif isinstance(stmt, SchemaDef):
                self._schemas.append(stmt)
            elif isinstance(stmt, AgentDef):
                self._agents.append(stmt)
            elif isinstance(stmt, FlowDef):
                self._flows.append(stmt)
            elif isinstance(stmt, EventHandler):
                self._handlers.append(stmt)

    def _emit_header(self, source_file: str) -> None:
        """Emit the file header comment.

        Args:
            source_file: Name of the source file.

        """
        header = GENERATED_HEADER.format(source_file=source_file)
        for line in header.rstrip().split("\n"):
            self._emitter.emit_raw(line)

    def _emit_imports(self) -> None:
        """Emit the required imports."""
        for line in IMPORTS.rstrip().split("\n"):
            self._emitter.emit_raw(line)
        self._emitter.emit_blank()

    def _emit_class_definition(self, source_file: str) -> None:
        """Emit the workflow class definition.

        Args:
            source_file: Name of the source file.

        """
        # Generate class name from source file
        class_name = self._generate_class_name(source_file)

        self._emitter.emit(f"class {class_name}(DslAgentWorkflow):")
        self._emitter.indent()

        # Class docstring
        self._emitter.emit(f'"""Generated workflow from {source_file}."""')
        self._emitter.emit_blank()

        # Emit class attributes
        self._emit_models()
        self._emit_prompts()
        self._emit_tools()
        self._emit_agents()

        # Emit event handlers
        handler_visitor = HandlerVisitor(self._emitter)
        for handler in self._handlers:
            handler_visitor.visit(handler)

        # Emit flow methods
        flow_visitor = FlowVisitor(self._emitter)
        for flow in self._flows:
            flow_visitor.visit(flow)

        # If no methods emitted, add pass
        if not self._handlers and not self._flows:
            self._emitter.emit("pass")

        self._emitter.dedent()

    def _generate_class_name(self, source_file: str) -> str:
        """Generate a class name from the source file name.

        Args:
            source_file: Name of the source file.

        Returns:
            Pascal case class name.

        """
        # Extract base name without extension
        name = source_file.replace(".sr", "").replace("/", "_").replace(".", "_")

        # Convert to PascalCase
        parts = name.replace("-", "_").split("_")
        pascal_name = "".join(part.capitalize() for part in parts if part)

        return f"{pascal_name}Workflow"

    def _emit_models(self) -> None:
        """Emit the _models class attribute."""
        if not self._models:
            self._emitter.emit("_models: dict[str, str] = {}")
            self._emitter.emit_blank()
            return

        self._emitter.emit("_models = {")
        self._emitter.indent()

        for model in self._models:
            source_line = model.meta.line if model.meta else None
            if model.provider_model:
                self._emitter.emit(
                    f"'{model.name}': '{model.provider_model}',",
                    source_line=source_line,
                )
            elif model.properties:
                # Long form model - emit as dict
                props = model.properties
                provider = props.get("provider", "")
                self._emitter.emit(
                    f"'{model.name}': '{provider}',",
                    source_line=source_line,
                )

        self._emitter.dedent()
        self._emitter.emit("}")
        self._emitter.emit_blank()

    def _emit_prompts(self) -> None:
        """Emit the _prompts class attribute."""
        if not self._prompts:
            self._emitter.emit("_prompts: dict[str, str] = {}")
            self._emitter.emit_blank()
            self._emitter.emit("_prompt_models: dict[str, str] = {}")
            self._emitter.emit_blank()
            return

        self._emitter.emit("_prompts = {")
        self._emitter.indent()

        for prompt in self._prompts:
            source_line = prompt.meta.line if prompt.meta else None
            # Generate prompt as lambda for variable interpolation
            body = self._process_prompt_body(prompt.body)
            self._emitter.emit(
                f"'{prompt.name}': lambda ctx: {body},",
                source_line=source_line,
            )

        self._emitter.dedent()
        self._emitter.emit("}")
        self._emitter.emit_blank()

        # Emit prompt model associations
        prompts_with_models = [p for p in self._prompts if p.model]
        if not prompts_with_models:
            self._emitter.emit("_prompt_models: dict[str, str] = {}")
            self._emitter.emit_blank()
            return

        self._emitter.emit("_prompt_models = {")
        self._emitter.indent()

        for prompt in prompts_with_models:
            source_line = prompt.meta.line if prompt.meta else None
            self._emitter.emit(
                f"'{prompt.name}': '{prompt.model}',",
                source_line=source_line,
            )

        self._emitter.dedent()
        self._emitter.emit("}")
        self._emitter.emit_blank()

    def _process_prompt_body(self, body: str) -> str:
        """Process prompt body for variable interpolation.

        Args:
            body: Original prompt body.

        Returns:
            Python expression for the prompt body.

        """
        import re

        # Find all $variable references
        var_pattern = r"\$\{?([a-zA-Z_][a-zA-Z0-9_]*)\}?"

        def replace_var(match: re.Match[str]) -> str:
            var_name = match.group(1)
            return "{ctx.vars['" + var_name + "']}"

        # Replace variables with f-string expressions
        processed = re.sub(var_pattern, replace_var, body)

        # Escape quotes for the f-string
        processed = processed.replace("\\", "\\\\")

        # Use triple-quoted f-string for multiline
        if "\n" in processed:
            return f'f"""{processed}"""'

        # Single line - use regular f-string
        processed = processed.replace('"', '\\"')
        return f'f"{processed}"'

    def _emit_tools(self) -> None:
        """Emit the _tools class attribute."""
        if not self._tools:
            self._emitter.emit("_tools: dict[str, dict[str, Any]] = {}")
            self._emitter.emit_blank()
            return

        self._emitter.emit("_tools = {")
        self._emitter.indent()

        for tool in self._tools:
            source_line = tool.meta.line if tool.meta else None
            self._emitter.emit(
                f"'{tool.name}': {{'type': '{tool.tool_type}', 'url': "
                f"{tool.url!r}}},",
                source_line=source_line,
            )

        self._emitter.dedent()
        self._emitter.emit("}")
        self._emitter.emit_blank()

    def _emit_agents(self) -> None:
        """Emit the _agents class attribute."""
        if not self._agents:
            self._emitter.emit("_agents: dict[str, dict[str, Any]] = {}")
            self._emitter.emit_blank()
            return

        self._emitter.emit("_agents = {")
        self._emitter.indent()

        for agent in self._agents:
            source_line = agent.meta.line if agent.meta else None
            name = agent.name or "default"
            tools_str = repr(agent.tools)

            # Start agent dict entry
            self._emitter.emit(f"'{name}': {{", source_line=source_line)
            self._emitter.indent()

            # Required fields
            self._emitter.emit(f"'tools': {tools_str},")
            self._emitter.emit(f"'instruction': '{agent.instruction}',")

            # Optional: sub_agents for delegate pattern
            if agent.delegate:
                sub_agents_str = ", ".join(f"'{a}'" for a in agent.delegate)
                self._emitter.emit(f"'sub_agents': [{sub_agents_str}],")

            # Optional: agent_tools for use pattern
            if agent.use:
                agent_tools_str = ", ".join(f"'{a}'" for a in agent.use)
                self._emitter.emit(f"'agent_tools': [{agent_tools_str}],")

            self._emitter.dedent()
            self._emitter.emit("},")

        self._emitter.dedent()
        self._emitter.emit("}")
        self._emitter.emit_blank()
